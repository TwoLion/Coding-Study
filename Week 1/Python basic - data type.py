
# Integer

# 정수를 다루는 자료형, 양의 정수, 음의 정수, 0 포함

# 양의 정수
a = 1000
print(a)

# 음의 정수
a = -7
print(a)

# 0
a = 0
print(a)

# Real number

# 소수점 아래의 데이터를 포함하는 수

# 양의 실수
a = 157.93
print(a)

# 음의 실수
a=-1837.2
print(a)

# 소수부가 0일 때 0을 생략
a = 5.
print(a)

# 정수부가 0일 때 0을 생략
a=.7
print(a)


# 지수 표현 방식

#e 또는 E를 이용하여 10의 지수 표현 가능

# 1,000,000,000 지수 표현방식

a = 1e9
print(a)

# 752.5

a=75.25e1
print(a)

# 3.954
a=3954e-3
print(a)

# e를 이용하여 표현하는 경우 실수형 자료로 취급함, int 함수 이용하여 정수형으로 변환 가능 - 실수연산 시 발생하는 오차 없앨 수 있음

# 150

a=15e1
print(type(a))
print(type(int(a)))

# 실수형 저장시 4바이트 또는 8바이트라는 고정된 크기의 메모리를 할당하기 때문에, 대체로 실수 정보를 표현하는 정확도에 한계 발생

a = 0.3+0.6

if a == 0.9:
    print(True
          )
else:
    print(False)


# 해결방법 :round()함수 또는 format 함수 이용하기(반올림 함수)


if round(a, 4) == 0.9:
    print(True)
else:
    print(False)



# 수 자료형의 연산

# 사칙연산 (+, -, *, /) 사용
# / 결과는 실수형으로 처리함
# % : 나머지 연산자 - 많이 사용됨
# // : 몫 연산자
# ** : 거듭 제곱 연산자

a=7
b=3

# 나누기

print(a/b)

# 나머지
print(a%b)

# 제곱근

print(a**.5)


###############################################################################################

# List 자료형

# 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형

# 기본 리스트 선언 : ([]) 안에 원소 넣어 초기화, 쉼표로 원소 구분, 비어있는 리스트 : []
# 리스트 원소 접근 : index 값 사용 - 0부터 시작함

# list 생성

a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a)

# 네 번째 원소 출력
print(a[3])

# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
n=10
a=[0]*n
print(a)

# list indexing

# 인덱스 값을 입력하여 리스트의 특정한 원소 접근 : 인덱싱
# 음의 정수를 넣으면 원소를 거꾸로 탐색

a =[1, 2, 3, 4, 5, 6, 7, 8, 9]

#여덟번째 원소 출력
print(a[7])

# 뒤에서 첫 번째 원소 출력
print(a[-1])

# 뒤에서 세 번째 원소 출력
print(a[-3])

# slicing

# 연속적인 위치를 갖는 원소 가져올 때 사용
# 대괄호 안에 콜론(:)를 넣어서 시작 인덱스와 끝 인덱스 설정
# 끝 인덱스는 실제 인덱스보다 1을 더 크게 설정함

a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 두 번째 원소부터 네 번째 원소까지 출력
print(a[1:4])

# list comprehension

#리스트 초기화하는 방법 중 하나
# 대괄호 안에 조건문과 반복문을 적용하여 리스트 초기화 가능

# 0부터 9까지 수를 포함하는 리스트

array = [i for i in range(10)]
print(array)

# [] 안 반복문 먼저 넣을 것

# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트

array = [i for i in range(20) if i%2 == 1]

print(array)

# 1부터 9까지의 수들의 제곱 값을 포함하는 리스트
array = [i*i for i in range(10)]

print(array)

# 리스트 컴프리헨션은 2차원 리스트 초기화할 때 효과적으로 사용 가능
# N*M 크기의 2차원 리스트를 한번에 초기화 해야 할 때 매우 유용
# ex : array =[[0]*m for _in range(n)]
# error : array = [[0]*m]*n
# 전체 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식됨

# N * M 크기의 2차원 리스트 초기화

n=4
m=3

array = [[0]*m for _ in range(n)]
print(array)

# 잘못된 방법

n=4
m=3

array = [[0]*m]*n
array[1][1]=5
print(array)


# 언더바 사용
# 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 언더바(_) 자주 사용

#기타 메서드

#append() : 원소 삽입 시 사용 O(1)
#sort(reverse=False) : 오름차순으로 정렬 O(NlogN)
#reverse() : 리스트 원소의 순서를 모두 뒤집어 놓는다 O(N)
#insert(삽입할 위치 인덱스, 삽입할 값) : 특정한 인덱스 위치에 원소를 삽입할 때 사용 O(N)
#count(특정값) : 리스트에서 특정한 값을 가지는 데이터 개수를 셀 때 사용 O(N)
#remove(특정값) : 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러개면 하나만 제거 O(N)

a=[1,4,3]
print('기본 리스트', a)

# 원소 삽입
a.append(2)
print('삽입 :', a)

# 오름차순 정렬
a.sort()
print('오름차순 정렬 :', a)

# 내림차순 정렬
a.sort(reverse=True)
print('내림차순 정렬 :', a)

# 리스트 원소 뒤집기
a.reverse()
print('원소 뒤집기 :', a)

# 특정 인덱스에 데이터 추가
a.insert(2, 3)
print("인덱스 2에 3 추가 :", a)

# 특정 값인 데이터 개수 세기
print('값이 3인 데이터 개수 :', a.count(3))

# 특정 값 데이터 삭제
a.remove(1)
print("값이 1인 데이터 삭제: ", a)

# 리스트에서 특정 값을 가지는 원소를 모두 제거하기

a = [1,2,3,4,5,5,5]
remove_set = {3, 5} # 집합 자료형

result= [i for i in a if i not in remove_set]
print(result)

########################################################################

# 문자열 자료형

# 문자열 변수를 초기화할 때는 큰따옴표나 작은 따옴표 이용
# 문자열 안에 큰따옴표나 작은따옴표가 포함되어야 하는 경우 있음
# 전체 문자열을 큰따옴표로 구성하는 경우, 내부적으로 작은따옴표를 포함할 수 있음.
# 전체 문자열을 작은따옴표로 구성하는 경우, 내부적으로 큰따옴표를 포함할 수 있음.
# 벡슬레시(\) 사용시, 큰따옴표나 작은따옴표 원하는 만큼 포함 가능

data ='Hello World'
print(data)

data = "Don't you know \"Python\"?"
print(data)

# 문자열 연산

# 문자열 변수에 덧셈(+)을 이용면 문자열이 더해져서 연결됨
# 문자열 변수를 특정한 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러 번 더해짐
# 문자열에 대해서도 인덱싱과 슬라이싱이 가능하나, 특정 인덱스 값을 변경할 수는 없음

a = "Hello"
b = "World"
print(a + " " + b)

a = "String"
print(a*3)

a = "ABCDEF"
print(a[2:4])


#########################################################################

# 튜플 자료형

# 차이점 1 : 한번 선언된 값을 변경할 수 없음
# 차이점 2 : 튜플은 소괄호((를 이용함
# 차이점 3 : 리스트에 비해 상대적으로 공간효율적

a =(1, 2, 3, 4, 5, 6, 7, 8, 9)

#네 번빼 원소만 출력
print(a[3])

# 두 번째 원소부터 네 번째 원소까지

print(a[1:4])

# 튜플 사용하면 좋은 경우
# 서로 다른 성질의 데이터를 묶어서 관리해야 할 때
# - 최단 경로 알고리즘에서는 (비용, 노드 번호)의 형태로 튜플 자료형을 자주 사용.
# 데이터의 나열을 해싱(Hashing)의 키 값으로 사용해야 할 때
# - 튜플은 변경이 불가능하므로 리스트와 다르게키 값으로 사용될 수 있음
# 리스트보다 메모리를 효율적으로 사용해야 할 때


#####################################################################

# 사전 자료형

# 키(Key)와 값(Value)의 쌍을 데이터로 가지는 자료형
# 0 순차적으로 저장하는 것과 대비 됨.
# 사전 자료형은 키와 값을 쌍을 데이터로 가지며, 원하는 '변경 불가능한 자료형'을 키로 사용
# 파이썬의 사전 자료형은 해시 테이블을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있음.

data = dict()

data['사과'] = 'Apple'
data['바나나']='Banana'
data['코코넛']='Coconut'

print(data)

if '사과' in data:
    print("'사과'를 키로  가지는 데이터가 존재합니다.")


# 키 데이터만 뽑고 싶을 때 : dict.keys()
# 값 데이터만 뽑고 싶을 때 : dict.values()

key_list = data.keys()
value_list = data.values()
print(key_list)
print(list(key_list))
print(value_list)
print(list(value_list))

# 각 키에 따른 값을 하나씩 출력
for key in key_list:
    print(data[key])


#####################################################################

# 집합 자료형
# 특징 1 : 중복을 허용하지 않음
# 특징 2 : 순서가 없음

# 집합은 리스트 혹은 문자열을 이용하여 초기화 가능
# - set() 함수 이용용
# 또는 {} 안에 각 원소를 콤마 기준으로 구분하여 삽입
# 데이터 조회 및 수정에 있어서 O(1)의 시간에 처리 가능

data = set([1, 1, 2, 3, 4, 4, 5])
print(data)
data = {1, 1, 2, 3, 4, 4, 5}
print(data)

# 집합 자료형 연산 : 합집합, 교집합, 차집합
# 합집합 : |
# 교집합 : &
# 차집합 : -

a = set([1, 2, 3, 4, 5])
b = set([3, 4, 5, 6, 7])

# 합집합
print(a|b)

# 교집합
print(a & b)

# 차집합
print(a-b)

#추가 함수
# add : 새로운 원소 1개 추가
# update(list) : 새로운 원소 여러 개 추가
# remove(값) : 특정한 값을 갖는 원소 삭제
# 상수 시간 사용

data = set([1, 2, 3])
print(data)

# add

data.add(4)
print(data)

#update

data.update([5, 6])
print(data)

# remove

data.remove(3)
print(data)


# 특징
# 리스트나 튜플은 순서가 있기 때문에 인덱싱을통해 자료형의 값을 얻을 수 있음
# 사전 자료형과 집합 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없음
# 사전의 키(Key) 혹은 집합의 원소(Element)를 이용해 O(1)의 시간 복잡도로 조회.
